use super::parse_rstml;
use super::RsxFileVisitor;
use super::RsxFileVisitorOut;
use super::WalkNodesOutput;
use proc_macro2::TokenStream;
use sweet_core::rsx::HtmlPartial;
use syn::visit_mut::VisitMut;
use syn::Expr;
use syn::File;


pub struct RsxParser {
	pub macro_ident: String,
}

impl Default for RsxParser {
	fn default() -> Self {
		Self {
			macro_ident: "rsx".to_string(),
		}
	}
}

impl RsxParser {
	/// header to add to the top of each rust file
	const SHEBANG: &'static str = "// 🍬 AUTOGENERATED BY SWEET 🍬\n// 🍬 AUTOGENERATED BY SWEET 🍬\n// 🍬 AUTOGENERATED BY SWEET 🍬";

	// entrypoint for file (preprosessor) parsing
	pub fn parse_file(
		&mut self,
		file: &str,
	) -> syn::Result<(File, RsxFileVisitorOut)> {
		let mut file = syn::parse_file(file)?;
		let mut visitor = RsxFileVisitor::new(self);
		visitor.visit_file_mut(&mut file);
		// Validate space
		file.shebang = Some(Self::SHEBANG.to_string());
		Ok((file, visitor.into()))
	}


	/// entrypoint for inline (macro) parsing.
	/// Called when visiting an rsx macro.
	/// Mutated in place for efficient file parsing
	pub fn parse_rsx(
		&mut self,
		tokens: &mut TokenStream,
	) -> syn::Result<WalkNodesOutput> {
		let (nodes, rstml_errors) = parse_rstml(tokens.clone());
		let mut output = WalkNodesOutput::default();

		output.html = HtmlPartial {
			nodes: output.visit_nodes(nodes),
		};

		let WalkNodesOutput {
			errors,
			html,
			rust,
			collected_elements,
			..
		} = output.clone();

		let _ = collected_elements;

		let include_errors = true;

		let errors = if include_errors {
			let errs = rstml_errors
				.into_iter()
				.map(|e| e.emit_as_expr_tokens())
				.chain(errors);
			quote::quote! {#(#errs;)*}
		} else {
			Default::default()
		};

		*tokens = syn::parse_quote! {{
			#errors
			sweet::prelude::RsxParts {
				rust: vec![#(#rust,)*],
				html: PathOrInline::Inline(#html),
			}
		}};
		Ok(output)
	}

	/// Check if a path matches the macro, by default only the last segment is checked
	pub fn path_matches(&self, path: &syn::Path) -> bool {
		path.segments
			.last()
			.map_or(false, |seg| seg.ident == self.macro_ident)
	}
}

pub fn macro_or_err(expr: &Expr) -> syn::Result<&syn::Macro> {
	if let Expr::Macro(mac) = expr {
		Ok(&mac.mac)
	} else {
		Err(syn::Error::new_spanned(expr, "expected macro"))
	}
}
