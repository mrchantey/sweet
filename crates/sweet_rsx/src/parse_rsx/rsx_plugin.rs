use super::RsxFileVisitor;
use super::RsxFileVisitorOut;
use super::WalkNodesOutput;
use proc_macro2::TokenStream;
use rstml::node::CustomNode;
use rstml::node::KeyedAttribute;
use rstml::node::NodeBlock;
use rstml::node::NodeElement;
use syn::visit_mut::VisitMut;
use syn::Expr;
use syn::File;





pub trait RsxPlugin: Sized {
	/// header to add to the top of each rust file
	const SHEBANG: &'static str = "// ðŸ¬ AUTOGENERATED BY SWEET ðŸ¬\n// ðŸ¬ AUTOGENERATED BY SWEET ðŸ¬\n// ðŸ¬ AUTOGENERATED BY SWEET ðŸ¬";

	// entrypoint for file (preprosessor) parsing
	fn parse_file(
		&mut self,
		file: &str,
	) -> syn::Result<(File, RsxFileVisitorOut)> {
		let mut file = syn::parse_file(file)?;
		let mut visitor = RsxFileVisitor::new(self);
		visitor.visit_file_mut(&mut file);
		// Validate space
		file.shebang = Some(Self::SHEBANG.to_string());
		Ok((file, visitor.into()))
	}


	/// entrypoint for inline (macro) parsing.
	/// Called when visiting an rsx macro.
	/// Mutated in place for efficient file parsing
	fn parse_rsx(
		&mut self,
		tokens: &mut TokenStream,
	) -> syn::Result<WalkNodesOutput>;

	fn visit_block(&mut self, block: &NodeBlock, output: &mut WalkNodesOutput);
	fn visit_event(
		&mut self,
		item: &KeyedAttribute,
		output: &mut WalkNodesOutput,
	);

	/// Opportunity to view children, useful for text node block encoding
	#[allow(unused_variables)]
	fn visit_element<C: CustomNode>(
		&mut self,
		el: &NodeElement<C>,
		output: &mut WalkNodesOutput,
	);

	/// specify the identifier that will be parsed, this is compared
	/// against the last part of a macro call,
	/// ie `sweet::prelude::rsx!` would be `rsx`
	fn macro_ident() -> &'static str { "rsx" }

	/// Check if a path matches the macro, by default only the last segment is checked
	fn path_matches(path: &syn::Path) -> bool {
		path.segments
			.last()
			.map_or(false, |seg| seg.ident == Self::macro_ident())
	}
}

pub fn macro_or_err(expr: &Expr) -> syn::Result<&syn::Macro> {
	if let Expr::Macro(mac) = expr {
		Ok(&mac.mac)
	} else {
		Err(syn::Error::new_spanned(expr, "expected macro"))
	}
}


#[cfg(test)]
mod test {

	// struct Foo(usize);

	// impl RsxPlugin for Foo {
	// 	fn visit_rsx(&mut self, _: &mut Expr) -> syn::Result<RsxPartsTokens> {
	// 		let id = self.0;
	// 		self.0 += 1;
	// 		Ok(RsxPartsTokens {
	// 			expr: syn::parse_quote! { #id },
	// 			..Default::default()
	// 		})
	// 	}
	// }

	#[test]
	fn works() {}
}
